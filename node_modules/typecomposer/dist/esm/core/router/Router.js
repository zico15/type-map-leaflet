class RouterController {
    _route = undefined;
    routePages = [];
    currentRoute = [];
    previousRoute = [];
    static _props = {};
    urlLast = "";
    constructor() {
        window.addEventListener("load", () => {
            if (this.route)
                this.updateRoute(this.route.history == "history" ? window.location.pathname : window.location.hash);
        });
        window.addEventListener("popstate", () => {
            if (this.route)
                this.updateRoute(this.route.history == "history" ? window.location.pathname : window.location.hash);
        });
    }
    doRoutesMatch(route1, route2) {
        // Replace '*' with a regex pattern that matches any segment
        const routePattern2 = route2.replace(/\*/g, "[a-zA-Z0-9-]+");
        // Create regex patterns for the routes
        const regex2 = new RegExp(`^${routePattern2}$`);
        // Test if both routes match each other
        return regex2.test(route1);
    }
    findCorrectRoute(pathname, routes = this.route?.routes || []) {
        if (routes) {
            for (const route of routes) {
                if (this.doRoutesMatch(pathname, route.path)) {
                    this.currentRoute.push({
                        ...route,
                        build: undefined,
                        routeView: undefined,
                        parent: this.currentRoute.length > 0 ? this.currentRoute[this.currentRoute.length - 1] : undefined,
                    });
                    return route.path;
                }
            }
            for (const route of routes) {
                if (route.children) {
                    this.currentRoute.push({
                        ...route,
                        build: undefined,
                        routeView: undefined,
                        parent: this.currentRoute.length > 0 ? this.currentRoute[this.currentRoute.length - 1] : undefined,
                    });
                    const r = this.findCorrectRoute(pathname, route.children);
                    if (r != "/")
                        return r;
                    else
                        this.currentRoute.pop();
                }
            }
        }
        return "/";
    }
    async buildRoute(routes = this.route?.routes, parent = "") {
        if (routes) {
            for (let route of routes) {
                route.path = parent + route.path;
                if (route.children) {
                    this.buildRoute(route.children, route.path == "/" ? route.path : route.path + "/");
                }
            }
        }
        return true;
    }
    async buildPages() {
        let routePageBuildLast = undefined;
        for (let i = 0; i < this.currentRoute.length; i++) {
            if (i + 1 < this.currentRoute.length && this.previousRoute[i] != undefined && this.currentRoute[i].id == this.previousRoute[i].id) {
                routePageBuildLast = this.previousRoute[i];
                this.currentRoute[i] = this.previousRoute[i];
                if (this.currentRoute[i + 1])
                    this.currentRoute[i + 1].parent = this.currentRoute[i];
            }
            else if (this.currentRoute[i].guard) {
                const fallbackRoute = this.currentRoute[i].guard.fallbackRoute;
                const result = await this.currentRoute[i].guard.beforeEach();
                if (!result) {
                    this.currentRoute = this.previousRoute;
                    Router.go(fallbackRoute || this.urlLast);
                    return;
                }
            }
        }
        const toBuild = this.currentRoute[0];
        if (toBuild.build == undefined) {
            toBuild.build = new toBuild.component();
            this.setView(toBuild.build);
        }
        if (routePageBuildLast?.routeView) {
            routePageBuildLast.routeView["updateView"]();
        }
        this.previousRoute = this.currentRoute;
        this.urlLast = window.location.pathname;
    }
    updateRoute(pathname) {
        const { url, parameters } = this.extractParametersURL(pathname);
        Router["_props"] = parameters;
        pathname = url.replace(/^#/, "");
        if (pathname.charAt(0) != "/")
            pathname = "/" + pathname;
        this.previousRoute = this.currentRoute;
        this.currentRoute = [];
        this.findCorrectRoute(pathname);
        if (this.currentRoute.length == 0)
            this.pageNotFound();
        else
            this.buildPages();
    }
    getProps(routePage) {
        let props = {};
        if (routePage) {
            props = this.props[routePage.id.split("_")[0]] || {};
        }
        return props;
    }
    get route() {
        return this._route;
    }
    set route(value) {
        this._route = value;
        const isHistory = this.buildRoute();
        let pathname = window.location.pathname;
        if (pathname.charAt(pathname.length - 1) == "/") {
            pathname = pathname.substring(0, pathname.length - 1) || "/";
        }
        if (this.route.history == "hash") {
            pathname = window.location.hash.replace(/^#/, "");
        }
        if (isHistory)
            this.addHistory(pathname);
    }
    get props() {
        return RouterController._props;
    }
    set props(value) {
        RouterController._props = value;
    }
    addHistory(pathname) {
        pathname = pathname.replace(/^#/, "");
        if (pathname.charAt(0) != "/")
            pathname = "/" + pathname;
        if (this.route.history == "hash")
            window.location.hash = "#" + pathname;
        else
            window.history.pushState({}, "", pathname);
    }
    getRouteViewFree(routeView) {
        // @ts-ignore
        let index = Array.from(document.querySelectorAll("route-view") || []).findIndex((r) => r == routeView);
        if (index == -1 || index >= this.currentRoute.length)
            return undefined;
        this.currentRoute[index++].routeView = routeView;
        return this.currentRoute.length > index ? this.currentRoute[index] : undefined;
    }
    getView(routeView) {
        if (routeView) {
            if (routeView.build == undefined) {
                routeView.build = new routeView.component();
            }
            return routeView.build;
        }
        return undefined;
    }
    pageNotFound() {
        if (this.route?.pageNotFound)
            this.setView(new this.route.pageNotFound());
        else {
            const body = document.createElement("body");
            body.style.width = "100%";
            body.style.height = "100%";
            body.style.overflow = "hidden";
            body.style.position = "fixed";
            body.innerHTML =
                "<div style='text-align: center;'>" +
                    "<h1 style='text-shadow: 0 3px 0px $color-base, 0 6px 0px #333; color: #f54f59; font-size: 6em; font-weight: 700; line-height: 0.6em;'>404</h1>" +
                    "<h1 style='text-shadow: 0 3px 0px $color-base, 0 6px 0px #333; color: #f54f59; font-size: 10; font-weight: 15; line-height: 0.6em;'>Page not found</h1>" +
                    "</div>";
            document.body = body;
        }
    }
    setView(view) {
        if (!(document.body.lastElementChild instanceof HTMLScriptElement))
            document.body?.lastElementChild?.remove();
        document.body.appendChild(view);
    }
    extractParametersURL(url) {
        const parameters = {};
        const queryString = url.includes("?") ? url.split("?")[1] : "";
        const pares = queryString.split("&");
        pares.forEach((par) => {
            const [chave, valor] = par.split("=");
            parameters[decodeURIComponent(chave)] = decodeURIComponent(valor);
        });
        return {
            url: url.split("?")[0],
            parameters: parameters,
        };
    }
}
export class Router {
    routes;
    history;
    pageNotFound;
    static controller = new RouterController();
    static _props = {};
    constructor(routes = [], history = "history", pageNotFound = undefined) {
        this.routes = routes;
        this.history = history;
        this.pageNotFound = pageNotFound;
        Router.createAutoId(this.routes, 0);
    }
    beforeEach(callback) { }
    static get props() {
        return Router._props;
    }
    static create(data) {
        if (Router.controller.route)
            throw new Error("Router already exists");
        Router.controller.route = new Router(data.routes, data.history, data.pageNotFound);
    }
    static buildURL(baseUrl, parametros) {
        const queryString = Object.keys(parametros)
            .map((key) => encodeURIComponent(key) + "=" + encodeURIComponent(parametros[key]))
            .join("&");
        return baseUrl + "?" + queryString;
    }
    static createAutoId(routes = [], id) {
        for (const route of routes) {
            route["id"] = `${route.path}_${++id}`;
            if (route.children) {
                id = this.createAutoId(route.children, id);
            }
        }
        return id;
    }
    static async go(pathname, props = {}) {
        pathname = Router.buildURL(pathname, props);
        this.controller.addHistory(pathname);
    }
}
//# sourceMappingURL=Router.js.map