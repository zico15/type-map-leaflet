"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => TypeComposer
});
module.exports = __toCommonJS(src_exports);

// src/plugin/pwa/index.ts
var import_node_fs2 = require("fs");

// src/plugin/pwa/serviceWorker.ts
var import_node_path = require("path");
var import_node_fs = require("fs");
function listDir(path4, ignoreFiles) {
  const files = [];
  function listRecursively(diretorio) {
    const itens = (0, import_node_fs.readdirSync)(diretorio);
    itens.forEach((item) => {
      const pathFile = (0, import_node_path.join)(diretorio, item);
      if ((0, import_node_fs.statSync)(pathFile).isDirectory())
        listRecursively(pathFile);
      else {
        const file = (0, import_node_path.relative)(path4, pathFile);
        if (ignoreFiles.indexOf(file) == -1)
          files.push("./" + file);
      }
    });
  }
  listRecursively(path4);
  return files;
}
function sw(config, options) {
  const ignoreFiles = options?.ignoreFiles || [];
  ignoreFiles.push("sw.js");
  const staticAssets = listDir(config?.build?.outDir || "", ignoreFiles);
  staticAssets.push("./");
  const files = staticAssets.map((asset) => {
    return `'${asset}'`;
  });
  return {
    fileName: "sw.js",
    staticAssets,
    code: `

    const cacheName = "news-v1";
    const staticAssets = [
     ${files.join(",\n")}
    ];

    self.addEventListener("install", async (e) => {
      const cache = await caches.open(cacheName);
      await cache.addAll(staticAssets);
      return self.skipWaiting();
    });

    self.addEventListener("notificationclick", (event) => {
      event.notification.close();
      var fullPath = self.location.origin + event.notification.data.path;
      console.log(fullPath);
      clients.openWindow(fullPath);
    });

    self.addEventListener('push', (event) => {
      event.waitUntil(
        self.registration.showNotification('Notification Title', {
          body: 'Notification Body Text',
          icon: 'custom-notification-icon.png',
        });
      );
    });

    self.addEventListener('notificationclick', (event) => {
      event.notification.close(); 
      var fullPath = self.location.origin + event.notification.data.path; 
      clients.openWindow(fullPath); 
    });

    self.addEventListener("activate", (e) => {
      self.clients.claim();
    });

    self.addEventListener("fetch", async (e) => {
      const req = e.request;
      const url = new URL(req.url);

      if (url.origin === location.origin) {
        e.respondWith(cacheFirst(req));
      } else {
        e.respondWith(networkAndCache(req));
      }
    });

    async function cacheFirst(req) {
      const cache = await caches.open(cacheName);
      const cached = await cache.match(req);
      return cached || fetch(req);
    }

    async function networkAndCache(req) {
      const cache = await caches.open(cacheName);
      try {
        const fresh = await fetch(req);
        await cache.put(req, fresh.clone());
        return fresh;
      } catch (e) {
        const cached = await cache.match(req);
        return cached;
      }
    }
    `
  };
}

// src/plugin/pwa/notification.ts
function notification() {
  const a = {
    fileName: "notification-sw.js",
    code: `
        if ('Notification' in window) {
            const permissaoNotificacao = Notification.permission;
          
            if (permissaoNotificacao === 'granted') {
              // O usu\xE1rio j\xE1 concedeu permiss\xE3o para notifica\xE7\xF5es
              console.log('Permiss\xE3o j\xE1 concedida para notifica\xE7\xF5es');
            } else if (permissaoNotificacao !== 'denied') {
              // A permiss\xE3o ainda n\xE3o foi concedida ou negada, ent\xE3o solicitamos ao usu\xE1rio
              Notification.requestPermission().then((permissao) => {
                if (permissao === 'granted') {
                  console.log('Permiss\xE3o concedida para notifica\xE7\xF5es');
                  // Agora voc\xEA pode exibir notifica\xE7\xF5es
                  mostrarNotificacao();
                } else {
                  console.warn('Permiss\xE3o negada para notifica\xE7\xF5es');
                }
              });
            }
          }
    `
  };
  a.code = "";
  return a;
}

// src/plugin/pwa/register.ts
function register(options, indexjs) {
  return {
    fileName: "register-sw.js",
    code: `

        window.addEventListener('load', () => {
            loadpage();
            registerSW();
          });
          
          async function loadpage() {
            Notification.requestPermission();
            const res = await fetch('${indexjs}');
            console.log("loadpage: ", res);
          }
          
          async function registerSW() {
            if ('serviceWorker' in navigator) {
              try {
                await navigator.serviceWorker.register('./sw.js');
              } catch (e) {
                console.log('SW registration failed');
              }
            }

            ${notification().code}
    
          }

    `
  };
}

// src/plugin/Debug/Log.ts
var Debuger;
((Debuger2) => {
  Debuger2.isDebug = true;
  function log(message, ...optional) {
    if (Debuger2.isDebug)
      console.log(message, ...optional);
  }
  Debuger2.log = log;
  function error(message, ...optional) {
    if (Debuger2.isDebug)
      console.error(message, ...optional);
  }
  Debuger2.error = error;
  function warn(message, ...optional) {
    if (Debuger2.isDebug)
      console.warn(message, ...optional);
  }
  Debuger2.warn = warn;
  function info(message, ...optional) {
    if (Debuger2.isDebug)
      console.info(message, ...optional);
  }
  Debuger2.info = info;
})(Debuger || (Debuger = {}));

// src/plugin/pwa/index.ts
async function injectServiceWorker(config, options, indexjs) {
  let html = (0, import_node_fs2.readFileSync)(`${config.build.outDir}/index.html`, "utf-8");
  const registerSw = register(options, indexjs);
  html = html.replace(
    "</head>",
    `<link rel="manifest" href="./manifest.webmanifest" />
        <script type="module" src="/${registerSw.fileName}"></script>
        </head>`
  );
  (0, import_node_fs2.writeFileSync)(`${config.build.outDir}/index.html`, html);
  (0, import_node_fs2.writeFileSync)(`${config.build.outDir}/${registerSw.fileName}`, registerSw.code);
  const file = sw(config, options);
  (0, import_node_fs2.writeFileSync)(`${config.build.outDir}/${file.fileName}`, file.code);
}
function autoManifest(config) {
  return void 0;
}
function PwaBuildPlugin(options) {
  let config = void 0;
  let indexjs = void 0;
  const transformIndexHtmlHandler = (html) => {
  };
  return {
    name: "typecompose:pwa",
    enforce: "post",
    apply: "build",
    transformIndexHtml: {
      order: "post",
      handler(html) {
        return transformIndexHtmlHandler(html);
      },
      enforce: "post",
      // deprecated since Vite 4
      async transform(html) {
        return transformIndexHtmlHandler(html);
      }
    },
    configResolved(_config) {
      config = _config;
      if (options.manifest === "auto")
        options.manifest = autoManifest(config);
    },
    generateBundle(n, bundle) {
      for (const key in bundle) {
        if (bundle[key].type == "chunk")
          indexjs = bundle[key].fileName;
      }
    },
    closeBundle: {
      sequential: true,
      order: "post",
      async handler() {
        if (options.manifest && config && indexjs) {
          (0, import_node_fs2.writeFileSync)(`${config.build.outDir}/manifest.webmanifest`, JSON.stringify(options.manifest));
          await injectServiceWorker(config, options, indexjs);
          Debuger.log("closeBundle");
        } else
          Debuger.warn("no manifest");
      }
    },
    async buildEnd(error) {
      if (error)
        throw error;
    }
  };
}

// src/plugin/transpilator/base/Style.ts
var import_node_fs3 = require("fs");
var import_node_path2 = require("path");
var StyleBuild = class {
  static {
    this.path = "public/style.scss";
  }
  static {
    this.identifier = "virtual:stylebase";
  }
  static read(classInfo, html) {
    const styles = html.match(/<(style|script)\b[^>]*>[\s\S]*?<\/\1>/g);
    classInfo.styles = [];
    let styleComponent = "";
    if (styles != void 0) {
      styles.forEach((style, index) => {
        const styleTag = style.split(">")[0];
        if (classInfo.registerOptions.tag != "" && !styleTag.includes("global")) {
          html = html.replace(styles[index], "");
          style = style.split(">\n")[1];
          style = style.split("</style>")[0];
          styleComponent += style;
        }
      });
      const regex = /\.this\s*\{([^}]*)\}/g;
      styleComponent = styleComponent.replace(regex, (match, group1) => group1.trim());
      Debuger.info("styleComponent: ", styleComponent);
    }
    if (styleComponent != "")
      classInfo.styles.push(`${classInfo.registerOptions.tag} {
${styleComponent.trim()}
}`.trim());
    return html;
  }
  static async getStyleUrl(fileInfo, classInfo, styleUrl) {
    if (styleUrl)
      styleUrl = styleUrl?.includes("src/") ? classInfo.registerOptions.styleUrl : "src/" + classInfo.registerOptions.styleUrl;
    if (styleUrl == void 0)
      styleUrl = (0, import_node_path2.join)((0, import_node_path2.dirname)(fileInfo.path), `${classInfo.className}.scss`);
    if (styleUrl == void 0)
      return void 0;
    styleUrl = (0, import_node_path2.normalize)(styleUrl);
    if (styleUrl && (0, import_node_fs3.existsSync)(styleUrl))
      return styleUrl;
    styleUrl = (0, import_node_path2.join)((0, import_node_path2.dirname)(fileInfo.path), `${classInfo.className}.css`);
    styleUrl = (0, import_node_path2.normalize)(styleUrl);
    return (0, import_node_fs3.existsSync)(styleUrl) ? styleUrl : void 0;
  }
  static async anliyze(fileInfo, classInfo) {
    classInfo.registerOptions.styleUrl = await this.getStyleUrl(fileInfo, classInfo, classInfo.registerOptions?.styleUrl);
  }
  static getStyleCode(fileInfo) {
    let styleCode = fileInfo.classes.filter((e) => e.styles.length > 0);
    if (styleCode == void 0 || styleCode.length == 0)
      return "";
    return styleCode.map((e) => e.styles.join("\n")).join("\n");
  }
  static async getStyleCodeAll(project) {
    let styleCode = "";
    for await (const fileInfo of project.files.values()) {
      styleCode += "\n" + this.getStyleCode(fileInfo);
    }
    return styleCode;
  }
  static async build(fileInfo, code) {
    fileInfo.styleCode = this.getStyleCode(fileInfo);
    if (fileInfo.styleCode != "") {
      let name = fileInfo.path.split("/").pop();
      name = name?.split(".")[0] || name;
      const timestamp = Date.now();
      fileInfo.virtualFile = `virtual:stylebase${name}${timestamp}.scss`;
      code = `import "${fileInfo.virtualFile}";
${code}`;
    } else
      fileInfo.virtualFile = void 0;
    for await (const classInfo of fileInfo.classes) {
      if (classInfo.registerOptions?.styleUrl && (0, import_node_fs3.existsSync)(classInfo.registerOptions.styleUrl)) {
        let url = classInfo.registerOptions.styleUrl;
        code = `import "${url}";
${code}`;
      }
    }
    return code;
  }
};

// src/plugin/transpilator/index.ts
function typeComposerPlugin(project) {
  return {
    name: "typescript-elements",
    enforce: "pre",
    watchChange(id, change) {
      project.watchChange(id, change);
    },
    resolveDynamicImport({}, importee, importer) {
      return importee;
    },
    configureServer(server) {
    },
    async buildStart() {
      await project.buildStart();
    },
    transformIndexHtml(html) {
      return html;
    },
    generateBundle(options, bundle) {
    },
    writeBundle(options, bundle) {
    },
    async configResolved(config) {
      project.projectDir = config.root + "/src";
      project.indexPath = config.root + "/index.html";
    },
    async load(id) {
      if (id.includes(StyleBuild.identifier)) {
        const fileInfo = Array.from(project.files.values()).find((e) => e.virtualFile && id.includes(e.virtualFile));
        if (fileInfo) {
          return fileInfo.styleCode;
        }
      }
      return null;
    },
    async resolveId(id, importer) {
      if (id.includes(StyleBuild.identifier)) {
        const fileInfo = Array.from(project.files.values()).find((e) => e.virtualFile && id.includes(e.virtualFile));
        if (fileInfo) {
          return {
            id,
            external: true,
            context: fileInfo.styleCode,
            moduleSideEffects: false
          };
        }
      }
    },
    async handleHotUpdate({ file, server }) {
      if (file.endsWith(".html")) {
        project.isFileTemplate(file);
        for await (const fileInfo of project.files.values()) {
          if (fileInfo.templatesUrl.length > 0 && fileInfo.templatesUrl.includes(file)) {
            project.sendServerUpdate(fileInfo);
            server.ws.send({
              type: "custom",
              event: "file-changed",
              data: {
                path: fileInfo.path,
                change: "reload"
              }
            });
          }
        }
      }
    },
    async transform(code, id) {
      if (!id.includes("node_modules"))
        return await project.transform(code, id);
    }
  };
}

// src/plugin/build/index.ts
var import_node_fs4 = require("fs");
var safariPolyfill = 'if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {const{keys:e}=Object,t=!0,r=!1,n="querySelectorAll",o="querySelectorAll",{document:l,Element:s,MutationObserver:a,Set:c,WeakMap:u}=self,i=e=>o in e,{filter:d}=[];var h=e=>{const h=new u,f=(t,r)=>{let n;if(r)for(let o,l=(e=>e.matches||e.webkitMatchesSelector||e.msMatchesSelector)(t),s=0,{length:a}=p;s<a;s++)l.call(t,o=p[s])&&(h.has(t)||h.set(t,new c),n=h.get(t),n.has(o)||(n.add(o),e.handle(t,r,o)));else h.has(t)&&(n=h.get(t),h.delete(t),n.forEach((n=>{e.handle(t,r,n)})))},g=(e,t=!0)=>{for(let r=0,{length:n}=e;r<n;r++)f(e[r],t)},{query:p}=e,b=e.root||l,y=((e,o=document,l=MutationObserver,s=["*"])=>{const a=(r,o,l,s,c,u)=>{for(const i of r)(u||n in i)&&(c?l.has(i)||(l.add(i),s.delete(i),e(i,c)):s.has(i)||(s.add(i),l.delete(i),e(i,c)),u||a(i[n](o),o,l,s,c,t))},c=new l((e=>{if(s.length){const n=s.join(","),o=new Set,l=new Set;for(const{addedNodes:s,removedNodes:c}of e)a(c,n,o,l,r,r),a(s,n,o,l,t,r)}})),{observe:u}=c;return(c.observe=e=>u.call(c,e,{subtree:t,childList:t}))(o),c})(f,b,a,p),{attachShadow:w}=s.prototype;return w&&(s.prototype.attachShadow=function(e){const t=w.call(this,e);return y.observe(t),t}),p.length&&g(b[o](p)),{drop:e=>{for(let t=0,{length:r}=e;t<r;t++)h.delete(e[t])},flush:()=>{const e=y.takeRecords();for(let t=0,{length:r}=e;t<r;t++)g(d.call(e[t].removedNodes,i),!1),g(d.call(e[t].addedNodes,i),!0)},observer:y,parse:g}};const{customElements:f,document:g,Element:p,MutationObserver:b,Object:y,Promise:w,Map:m,Set:S,WeakMap:v,Reflect:A}=self,{createElement:E}=g,{define:M,get:O,upgrade:q}=f,{construct:k}=A||{construct(e){return e.call(this)}},{defineProperty:N,getOwnPropertyNames:$,setPrototypeOf:P}=y,C=new v,j=new S,V=new m,L=new m,R=new m,T=new m,W=[],_=[],x=e=>T.get(e)||O.call(f,e),{parse:D}=h({query:_,handle:(t,r,n)=>{const o=R.get(n);if(r&&!o.isPrototypeOf(t)){const r=(t=>{const r=e(t),n=[],o=new Set,{length:l}=r;for(let e=0;e<l;e++){n[e]=t[r[e]];try{delete t[r[e]]}catch(t){o.add(e)}}return()=>{for(let e=0;e<l;e++)o.has(e)||(t[r[e]]=n[e])}})(t);B=P(t,o);try{new o.constructor}finally{B=null,r()}}const l=(r?"":"dis")+"connectedCallback";l in o&&t[l]()}}),{parse:F}=h({query:W,handle(e,t){C.has(e)&&(t?j.add(e):j.delete(e),_.length&&G.call(_,e))}}),{attachShadow:H}=p.prototype;H&&(p.prototype.attachShadow=function(e){const t=H.call(this,e);return C.set(this,t),t});const I=e=>{if(!L.has(e)){let t,r=new w((e=>{t=e}));L.set(e,{$:r,_:t})}return L.get(e).$},z=((e,t)=>{const r=e=>{for(let t=0,{length:r}=e;t<r;t++)n(e[t])},n=({target:e,attributeName:t,oldValue:r})=>{e.attributeChangedCallback(t,r,e.getAttribute(t))};return(o,l)=>{const{observedAttributes:s}=o.constructor;return s&&e(l).then((()=>{new t(r).observe(o,{attributes:!0,attributeOldValue:!0,attributeFilter:s});for(let e=0,{length:t}=s;e<t;e++)o.hasAttribute(s[e])&&n({target:o,attributeName:s[e],oldValue:null})})),o}})(I,b);let B=null;function G(e){const t=C.get(e);D(t.querySelectorAll(this),e.isConnected)}$(self).filter((e=>/^HTML.*Element$/.test(e))).forEach((e=>{const t=self[e];function r(){const{constructor:e}=this;if(!V.has(e))throw new TypeError("Illegal constructor");const{is:r,tag:n}=V.get(e);if(r){if(B)return z(B,r);const t=E.call(g,n);return t.setAttribute("is",r),z(P(t,e.prototype),r)}return k.call(this,t,[],e)}P(r,t),N(r.prototype=t.prototype,"constructor",{value:r}),N(self,e,{value:r})})),g.createElement=function(e,t){const r=t&&t.is;if(r){const t=T.get(r);if(t&&V.get(t).tag===e)return new t}const n=E.call(g,e);return r&&n.setAttribute("is",r),n},f.get=x,f.whenDefined=I,f.upgrade=function(e){const t=e.getAttribute("is");if(t){const r=T.get(t);if(r)return void z(P(e,r.prototype),t)}q.call(f,e)},f.define=function(e,t,r){if(x(e))throw new Error(`\'${e}\' has already been defined as a custom element`);let n;const o=r&&r.extends;V.set(t,o?{is:e,tag:o}:{is:"",tag:e}),o?(n=`${o}[is="${e}"]`,R.set(n,t.prototype),T.set(e,t),_.push(n)):(M.apply(f,arguments),W.push(n=e)),I(e).then((()=>{o?(D(g.querySelectorAll(n)),j.forEach(G,[n])):F(g.querySelectorAll(n))})),L.get(e)._(t)};}';
function BuildPlugin(project) {
  let config = void 0;
  let indexjs = void 0;
  return {
    name: "typecomposer-pluginr-plugin:pwa",
    enforce: "pre",
    apply: "build",
    transformIndexHtml: {
      order: "post",
      handler(html) {
        return html;
      },
      enforce: "pre",
      // deprecated since Vite 4
      async transform(html) {
      }
    },
    configResolved(_config) {
      config = _config;
    },
    async generateBundle(n, bundle) {
      for (const [fileName, asset] of Object.entries(bundle)) {
        if (asset.type == "chunk")
          indexjs = fileName;
      }
    },
    resolveId(id, importer) {
      return null;
    },
    async transform(code, id, options) {
      if (id.includes("typecompose/styles/style.scss")) {
        const styleCode = code + await StyleBuild.getStyleCodeAll(project);
        return styleCode;
      }
      return null;
    },
    closeBundle: {
      sequential: true,
      order: "post",
      async handler() {
        if (indexjs && config) {
          const file = `${config.build.outDir}/${indexjs}`;
          let code = (0, import_node_fs4.readFileSync)(file, "utf-8");
          code = safariPolyfill + code;
          (0, import_node_fs4.writeFileSync)(file, code);
        }
      }
    },
    async buildEnd(error) {
      if (error)
        throw error;
    }
  };
}

// src/plugin/transpilator/ProjectBuild.ts
var import_ts_morph = require("ts-morph");
var import_node_fs9 = require("fs");

// src/plugin/transpilator/base/Register.ts
var import_node_fs5 = require("fs");
var RegisterBuild = class _RegisterBuild {
  static {
    this.index = 1;
  }
  static converClasNameToTag(classInfo) {
    if (classInfo.className == void 0)
      return `base-${Math.random().toString(36).substring(7)}-element`;
    let name = classInfo.className.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/(\d+)([A-Z])/g, "$1-$2").toLowerCase();
    if (classInfo.isExported == false) {
      _RegisterBuild.index++;
      name = `tmp-${name}-${Math.random().toString(36).substring(7) + _RegisterBuild.index.toString()}`;
    } else if (!name.includes("-"))
      name = name + "-element";
    return name;
  }
  static async readRegister(fileInfo, classInfo) {
    const decorators = classInfo.classDeclaration.getDecorators();
    const register2 = decorators.find((e) => e.getName() == "Register");
    const scoped = decorators.find((e) => e.getName() == "scoped");
    const registerArgs = register2?.getArguments().map((arg) => arg.getText().replace(/,(?=\s*})/, "")).join(", ").replace(/(\w+):/g, '"$1":').replace(/'/g, '"');
    if (scoped)
      classInfo.isExported = false;
    if (register2)
      fileInfo.removeDatas.push(register2.getText());
    try {
      classInfo.registerOptions = JSON.parse(registerArgs || "{}");
    } catch (error) {
      Debuger.error("error: ", error);
    }
    if (classInfo.registerOptions?.scoped)
      classInfo.isExported = !classInfo.registerOptions.scoped;
    if (classInfo.registerOptions?.extends == void 0)
      await this.readExtends(classInfo);
    if (classInfo.registerOptions.tag == void 0)
      classInfo.registerOptions.tag = this.converClasNameToTag(classInfo);
  }
  static async readExtends(classInfo) {
    if (classInfo.paranet != void 0 && classInfo.paranet.path != "") {
      try {
        const conteudo = (0, import_node_fs5.readFileSync)(classInfo.paranet.path, "utf8");
        const regex = /customElements\.define\(["'](.*?)["'].*?\)/g;
        const matches = conteudo.match(regex);
        for await (const match of matches || []) {
          const regex2 = /customElements\.define\(["']([^"']+)["'],\s*(\w+)\s*,\s*({[^}]+})\s*\)/;
          const match2 = match.match(regex2);
          if (match2 && match2[2] == classInfo.paranet?.className && match2[3]) {
            const extendsJson = match2[3].replace(/(\w+):/g, '"$1":');
            classInfo.registerOptions.extends = JSON.parse(extendsJson).extends;
            break;
          }
        }
      } catch (error) {
        Debuger.error("error: ", error);
      }
    }
  }
  static async injectTag(classInfo) {
    const tag = classInfo.registerOptions.tag;
    const line = `customElements.define("${tag}", ${classInfo.classDeclaration.getName()}, ${classInfo.registerOptions?.extends ? '{ extends: "' + classInfo.registerOptions.extends + '" }' : "undefined"});`;
    classInfo.afterClassDatas.push(line);
  }
  static async anliyze(fileInfo) {
    for await (const classInfo of fileInfo.classes) {
      await this.readRegister(fileInfo, classInfo);
      await this.injectTag(classInfo);
    }
  }
};

// src/plugin/transpilator/Interfaces.ts
function printFileInfo(fileInfo) {
  if (fileInfo.classes.length == 0)
    return;
  Debuger.log("============ fileInfo ============");
  Debuger.log("path: ", fileInfo.path);
  Debuger.log("templatesUrl: ", fileInfo.templatesUrl);
  Debuger.log("styleCode: ", fileInfo.styleCode);
  Debuger.log("virtualFile: ", fileInfo.virtualFile);
  Debuger.log("removeDatas: ", fileInfo.removeDatas);
  Debuger.log("startDatas: ", fileInfo.startDatas);
  Debuger.log("endDatas: ", fileInfo.endDatas);
  Debuger.log("imports: ", fileInfo.imports);
}

// src/plugin/transpilator/ProjectBuild.ts
var import_node_path6 = __toESM(require("path"), 1);

// src/plugin/transpilator/base/Template.ts
var import_node_fs6 = require("fs");
var import_node_path3 = require("path");
var TemplateBuild = class {
  static getTemplateUrl(fileInfo, classInfo, templateUrl) {
    if (templateUrl)
      templateUrl = templateUrl?.includes("src/") ? classInfo.registerOptions.templateUrl : "src/" + classInfo.registerOptions.templateUrl;
    if (templateUrl == void 0)
      templateUrl = (0, import_node_path3.join)((0, import_node_path3.dirname)(fileInfo.path), `${classInfo.className}.html`);
    if (templateUrl == void 0)
      return void 0;
    templateUrl = (0, import_node_path3.normalize)(templateUrl);
    if (templateUrl == void 0 || !(0, import_node_fs6.existsSync)(templateUrl))
      return void 0;
    return templateUrl;
  }
  static async readHtml(fileInfo, classInfo, templateUrl) {
    if (templateUrl == void 0)
      return;
    try {
      let html = (0, import_node_fs6.readFileSync)(templateUrl, "utf-8");
      html = StyleBuild.read(classInfo, html).trim();
      classInfo.constructorDatas.push(`this.innerHTML = \`${html}\`;`);
      templateUrl = (0, import_node_path3.resolve)(templateUrl);
      fileInfo.templatesUrl.push(templateUrl);
      return html.trim();
    } catch (error) {
      classInfo.registerOptions.templateUrl = void 0;
      return void 0;
    }
  }
  static async readRefComponent(fileInfo, classInfo, templateUrl) {
    const propertyDeclarations = classInfo.classDeclaration.getProperties();
    let variables = classInfo.classDeclaration.getProperties().filter((prop) => prop.getText().includes("!") && !prop.getText().includes("="));
    for (let i = 0; i < propertyDeclarations.length; i++) {
      const property = propertyDeclarations[i];
      const propertyDecorators = [...property.getDecorators()];
      propertyDecorators.forEach((decorator) => {
        if ("RefComponent" == decorator.getName()) {
          if (templateUrl != void 0) {
            let ref = decorator.getArguments().map((arg) => arg.getText()).join(", ").replace(/(\w+):/g, '"$1":');
            if (ref.includes("{") && ref.includes("}"))
              ref = JSON.parse(ref)?.id || property.getName();
            else
              ref = ref.replace(/"/g, "") || property.getName();
            const name = property.getName();
            variables = variables.filter((prop) => prop.getName() != name);
            classInfo.refComponents.push({ name, id: ref });
            classInfo.constructorDatas.push(`this.${name} = this.querySelector("#${ref}");`);
          }
          fileInfo.removeDatas.push(decorator.getText());
        }
      });
    }
    if (templateUrl == void 0)
      return;
    for (let i = 0; i < variables.length; i++) {
      const variable = variables[i];
      const name = variable.getName();
      classInfo.refComponents.push({ name, id: name });
      classInfo.constructorDatas.push(`this.${name} = this.querySelector("#${name}");`);
    }
  }
  static async anliyze(fileInfo) {
    for await (const classInfo of fileInfo.classes) {
      classInfo.registerOptions.templateUrl = this.getTemplateUrl(fileInfo, classInfo, classInfo.registerOptions?.templateUrl);
      await StyleBuild.anliyze(fileInfo, classInfo);
      await this.readHtml(fileInfo, classInfo, classInfo.registerOptions?.templateUrl);
      await this.readRefComponent(fileInfo, classInfo, classInfo.registerOptions?.templateUrl);
    }
  }
};

// src/plugin/transpilator/base/RouterController.ts
var import_node_path4 = __toESM(require("path"), 1);
var import_node_fs7 = require("fs");
var import_node_os = require("os");
var Router;
((Router2) => {
  function isRouterFile(file) {
    return file === "router.ts" || file === "router.js" || file === "Router.js" || file === "Router.ts";
  }
  Router2.isRouterFile = isRouterFile;
  async function findRouterTsFiles(directory) {
    const routerTsFiles = [];
    function searchRecursively(dir) {
      const files = (0, import_node_fs7.readdirSync)(dir);
      files.forEach((file) => {
        const filePath = import_node_path4.default.join(dir, file);
        const isDirectory = (0, import_node_fs7.statSync)(filePath).isDirectory();
        if (isDirectory) {
          searchRecursively(filePath);
        } else if (isRouterFile(file)) {
          routerTsFiles.push(filePath);
        }
      });
    }
    searchRecursively(directory);
    return routerTsFiles;
  }
  Router2.findRouterTsFiles = findRouterTsFiles;
  async function updateRouterFiles(routerPath, indexPath) {
    const regex = /<script(?:\s[^>]*)?\srouter(?:\s[^>]*)?>\s*<\/script>/g;
    const operatingSystem = (0, import_node_os.platform)();
    if (operatingSystem == "win32") {
      routerPath = routerPath.replace(/\\/g, "/");
    }
    if (routerPath.includes("/src"))
      routerPath = "/src" + routerPath.split("/src")[1];
    if (routerPath)
      routerPath = `src="${routerPath}"`;
    let html = (0, import_node_fs7.readFileSync)(indexPath, "utf-8");
    const resul = html.match(regex);
    if (resul) {
      html = html.replace(resul[0], `<script router type="module" ${routerPath} ></script>`);
      (0, import_node_fs7.writeFileSync)(indexPath, html);
    } else {
      html = html.replace("<head>", `<head>
            <script router type="module"  ${routerPath} ></script>`);
      (0, import_node_fs7.writeFileSync)(indexPath, html);
    }
  }
  Router2.updateRouterFiles = updateRouterFiles;
  async function watchChange(id, change, project) {
    if (change.event != "update" && (id.endsWith(".ts") || id.endsWith(".js")) && Router2.isRouterFile((0, import_node_path4.basename)(id))) {
      const routers = await Router2.findRouterTsFiles(project.projectDir);
      if (routers.length > 0) {
        project.routerPath = routers[0];
        await Router2.updateRouterFiles(project.routerPath, project.indexPath);
      } else {
        project.routerPath = "";
        await Router2.updateRouterFiles("", project.indexPath);
      }
    }
  }
  Router2.watchChange = watchChange;
})(Router || (Router = {}));

// src/plugin/transpilator/base/ThemeController.ts
var import_node_path5 = __toESM(require("path"), 1);
var import_node_fs8 = require("fs");
var Theme;
((Theme2) => {
  const files = [];
  function isThemeFile(file) {
    return getFileName(file) != void 0;
  }
  Theme2.isThemeFile = isThemeFile;
  function getFileName(file) {
    const regex_scss = /^theme-(.*?)\.scss$/;
    const regex_css = /^theme-(.*?)\.css$/;
    const result_1 = file.match(regex_css);
    if (result_1) {
      return result_1[1];
    }
    const result_2 = file.match(regex_scss);
    if (result_2) {
      return result_2[1];
    }
    return void 0;
  }
  function putFileTheme(path4, name) {
    if (files.find((e) => e.name == name) == void 0)
      files.push({ name, path: path4 });
  }
  Theme2.putFileTheme = putFileTheme;
  function clearFileTheme() {
    files.length = 0;
  }
  Theme2.clearFileTheme = clearFileTheme;
  function getFiles() {
    return files;
  }
  Theme2.getFiles = getFiles;
  async function findFiles(directory) {
    clearFileTheme();
    function searchRecursively(dir) {
      const files2 = (0, import_node_fs8.readdirSync)(dir);
      files2.forEach((file) => {
        const filePath = import_node_path5.default.join(dir, file);
        const isDirectory = (0, import_node_fs8.statSync)(filePath).isDirectory();
        if (isDirectory) {
          searchRecursively(filePath);
        } else if (isThemeFile(file)) {
          putFileTheme(filePath, getFileName(file));
        }
      });
    }
    searchRecursively(directory);
  }
  Theme2.findFiles = findFiles;
  async function watchChange(id, change, project) {
    if (change.event != "update" && (id.endsWith(".scss") || id.endsWith(".css")) && Theme2.isThemeFile((0, import_node_path5.basename)(id))) {
      const fileTheme = Theme2.getFiles().find((e) => e.path == id);
      if (change.event == "delete") {
        if (fileTheme) {
          Theme2.getFiles().splice(Theme2.getFiles().indexOf(fileTheme), 1);
        }
      } else {
        if (fileTheme == void 0) {
          Theme2.putFileTheme(id, getFileName((0, import_node_path5.basename)(id)));
        }
      }
    }
  }
  Theme2.watchChange = watchChange;
})(Theme || (Theme = {}));

// src/plugin/transpilator/base/Ref.ts
var RefBuild;
((RefBuild2) => {
  async function anliyze(fileInfo) {
  }
  RefBuild2.anliyze = anliyze;
})(RefBuild || (RefBuild = {}));

// src/plugin/transpilator/ProjectBuild.ts
var ProjectBuild = class extends import_ts_morph.Project {
  constructor() {
    super();
    this.files = /* @__PURE__ */ new Map();
    this.projectDir = "";
    this.indexPath = "";
    this.styleCode = "";
    this.pathClassMain = "";
    this.routerPath = "";
    this.path = this.getSourceFiles().find((e) => e.getFilePath().includes("node_modules/typecomposer-plugin"))?.getFilePath() || "";
    if (this.path != "")
      this.path = this.path.split("node_modules/typecomposer-plugin/")[0] + "node_modules/typecomposer-plugin/";
    this.stylePath = this.path + "public/style.scss";
    this.load_node_modules_dependencys();
  }
  async load_node_modules_dependencys() {
    const listaDependencies = ["node_modules/typecomposer"];
    try {
      const itens = (0, import_node_fs9.readdirSync)("node_modules");
      const pacotes = itens.filter((item) => (0, import_node_fs9.statSync)(import_node_path6.default.join("node_modules", item)).isDirectory() && item !== "." && item !== "..").map((item) => import_node_path6.default.join("node_modules", import_node_path6.default.join(item, "package.json"))).filter((item) => (0, import_node_fs9.existsSync)(item));
      for (const packageJsonPath of pacotes) {
        const packageJsonContent = (0, import_node_fs9.readFileSync)(packageJsonPath, "utf-8");
        const packageJson = JSON.parse(packageJsonContent);
        const dependencies = packageJson.dependencies || {};
        const devDependencies = packageJson.devDependencies || {};
        if (dependencies?.typecomposer || devDependencies?.typecomposer)
          listaDependencies.push(packageJsonPath.replace("package.json", ""));
      }
    } catch (error) {
      Debuger.error("error load_node_modules_dependencys: ", error);
    }
    for (const dependencie of listaDependencies) {
      this.addSourceFilesAtPaths(`${dependencie}/**/*.ts`);
    }
  }
  async buildStart() {
    const routers = await Router.findRouterTsFiles(this.projectDir);
    if (routers.length > 0) {
      this.routerPath = routers[0];
      await Router.updateRouterFiles(this.routerPath, this.indexPath);
    }
    Theme.findFiles(this.projectDir);
    Debuger.log("buildStart: ", Theme.getFiles());
  }
  async analyze(path4, code) {
    const sourceFile = this.createSourceFile("dummy.ts", code, { overwrite: true, scriptKind: 3 });
    const fileInfo = this.files.get(path4) || { sourceFile, classes: [], removeDatas: [], path: path4, templatesUrl: [], startDatas: [], endDatas: [], imports: [] };
    const classes = sourceFile.getClasses();
    fileInfo.sourceFile = sourceFile;
    fileInfo.removeDatas = [];
    fileInfo.startDatas = [];
    fileInfo.endDatas = [];
    fileInfo.path = path4;
    fileInfo.templatesUrl = [];
    printFileInfo(fileInfo);
    fileInfo.imports = this.getImportInfo(sourceFile);
    fileInfo.classes = classes.map((classDeclaration) => {
      return this.getClassInofo(classDeclaration, fileInfo);
    }).filter((classInfo) => classInfo.isComponent);
    await RegisterBuild.anliyze(fileInfo);
    await TemplateBuild.anliyze(fileInfo);
    await RefBuild.anliyze(fileInfo);
    this.files.set(path4, fileInfo);
    return await this.build(fileInfo);
  }
  async build(fileInfo) {
    for await (const classInfo of fileInfo.classes) {
      this.insertConstructorDatas(classInfo);
      this.injectFunctions(fileInfo.sourceFile, classInfo.classDeclaration);
    }
    let code = fileInfo.sourceFile.getFullText();
    for await (const classInfo of fileInfo.classes) {
      const afterClassDatas = classInfo.afterClassDatas.join("\n");
      code = code.replace(
        classInfo.classDeclaration.getText(),
        classInfo.classDeclaration.getText() + "\n" + afterClassDatas
      );
    }
    for await (const data of fileInfo.removeDatas) {
      code = code.replace(data, "");
    }
    for await (const data of fileInfo.startDatas) {
      code = data + code;
    }
    for await (const data of fileInfo.endDatas) {
      code = code + data;
    }
    fileInfo.removeDatas.length = 0;
    return await StyleBuild.build(fileInfo, code);
  }
  getClassInofo(classDeclaration, fileInfo) {
    const className = classDeclaration.getName();
    const extendsClause = classDeclaration.getExtends()?.getText();
    const decorators = classDeclaration.getDecorators()?.map((decorator) => decorator.getText()) || [];
    const { isComponent, paranet } = this.checkIsComponent(classDeclaration);
    return {
      className,
      extends: extendsClause,
      decorators,
      imports: JSON.stringify(fileInfo.imports),
      isComponent,
      classDeclaration,
      registerOptions: {},
      constructorDatas: [],
      styles: [],
      isExported: classDeclaration.isExported(),
      afterClassDatas: [],
      refComponents: [],
      paranet
    };
  }
  isClassFromModule(classDeclaration, moduleName) {
    const sourceFile = classDeclaration.getSourceFile();
    return sourceFile.getImportDeclarations().some((importDeclaration) => {
      return importDeclaration.getNamedImports().some((namedImport) => {
        return namedImport.getText() === classDeclaration.getName() && importDeclaration.getModuleSpecifierValue() === moduleName;
      });
    });
  }
  checkImplementsComponent(sourceFile, classDeclaration) {
    if (sourceFile && classDeclaration && classDeclaration.getImplements().map((e) => e.getText()).includes("IComponent")) {
      const i = sourceFile.getFilePath();
      if (i.includes("node_modules/typecomposer"))
        return { isComponent: true, paranet: { path: i.includes(".d.ts") ? i.replace(".d.ts", ".js") : i, className: classDeclaration.getName() || "" } };
    }
    return { isComponent: false, paranet: void 0 };
  }
  checkIsComponent(classDeclaration) {
    if (classDeclaration == void 0)
      return { isComponent: false, paranet: void 0 };
    const check = this.checkImplementsComponent(classDeclaration.getSourceFile(), classDeclaration);
    if (check.isComponent)
      return check;
    if (classDeclaration) {
      const extendsClause = classDeclaration.getHeritageClauses()[0];
      const extendsTypeNode = extendsClause ? extendsClause.getTypeNodes()[0] : void 0;
      if (extendsTypeNode) {
        const extendedClassName = extendsTypeNode.getText();
        const extendedClassDeclaration = this.getSourceFiles().find((sourceFile) => sourceFile.getClass(extendedClassName))?.getClass(extendedClassName);
        if (extendedClassDeclaration)
          return this.checkIsComponent(extendedClassDeclaration);
      }
    }
    return { isComponent: false, paranet: void 0 };
  }
  getImportInfo(sourceFile) {
    const imports = sourceFile.getImportDeclarations().map((importDeclaration) => {
      const moduleSpecifier = importDeclaration.getModuleSpecifierValue();
      const namedImports = importDeclaration.getNamedImports().map((namedImport) => namedImport.getText());
      return { moduleSpecifier, namedImports };
    });
    return imports;
  }
  insertConstructorDatas(classInfo) {
    const classDeclaration = classInfo.classDeclaration;
    try {
      let constructorDeclaration = classDeclaration.getConstructors()[0];
      if (constructorDeclaration == void 0) {
        constructorDeclaration = classDeclaration.addConstructor();
        if (classDeclaration.getExtends()) {
          constructorDeclaration.insertStatements(0, (writer) => {
            writer.write("super();");
          });
        }
      }
      const injectedLine = classInfo.constructorDatas.join("\n");
      constructorDeclaration.insertStatements(1, (writer) => {
        writer.write(injectedLine);
      });
      constructorDeclaration.insertStatements(constructorDeclaration.getStatements().length, (writer) => {
        writer.write("this.onInit();");
      });
    } catch (__) {
      Debuger.error("Error: ", __);
    }
  }
  injectFunctions(sourceFile, classDeclaration) {
    const connectedCallback = classDeclaration.getMethod("connectedCallback") || classDeclaration.addMethod({
      name: "connectedCallback",
      isAsync: false,
      isStatic: false,
      returnType: "void",
      statements: [],
      parameters: []
    });
    connectedCallback?.insertStatements(0, "this.onConnected();");
    const disconnectedCallback = classDeclaration.getMethod("disconnectedCallback") || classDeclaration.addMethod({
      name: "disconnectedCallback",
      isAsync: false,
      isStatic: false,
      statements: [],
      parameters: []
    });
    disconnectedCallback?.insertStatements(0, "this.unmount?.();this._styleRef?.disconnectedCallback();this.removeEvents?.(); this.onDisconnected();");
  }
  sendServerUpdate(fileInfo) {
    const now = /* @__PURE__ */ new Date();
    (0, import_node_fs9.utimesSync)(fileInfo.path, now, now);
  }
  async transform(code, id) {
    if (id.endsWith(".ts") || id.endsWith(".js") || id.endsWith(".tsx") || id.endsWith(".jsx")) {
      return await this.analyze(id, code);
    } else if (id.includes(StyleBuild.identifier)) {
    }
    return code;
  }
  async isFileTemplate(filePath) {
    const fileInfos = [];
    const fileName = import_node_path6.default.basename(filePath).replace(import_node_path6.default.extname(filePath), "");
    const fileDirName = import_node_path6.default.dirname(filePath);
    for (const fileInfo of this.files.values()) {
      if (import_node_path6.default.dirname(fileInfo.path) == fileDirName) {
        for (const classInfo of fileInfo.classes) {
          if (classInfo.className == fileName || classInfo.registerOptions.templateUrl == filePath) {
            fileInfos.push(fileInfo);
            break;
          }
        }
      }
    }
    return fileInfos;
  }
  async watchChange(id, change) {
    Router.watchChange(id, change, this);
    Theme.watchChange(id, change, this);
    if (id.endsWith(".html")) {
      if (change.event != "update") {
        const fileInfos = await this.isFileTemplate(id);
        for (const fileInfo of fileInfos) {
          this.sendServerUpdate(fileInfo);
        }
      }
    }
  }
};

// src/index.ts
function TypeComposer(options = {}) {
  const { pwa } = options;
  Debuger.isDebug = options.debuger || false;
  Debuger.log("activate typecomposer debuger");
  const project = new ProjectBuild();
  const plugins = [typeComposerPlugin(project), BuildPlugin(project)];
  if (pwa) {
    Debuger.log("activate pwa build");
    plugins.push(PwaBuildPlugin(pwa));
  }
  return [typeComposerPlugin(project)];
}
